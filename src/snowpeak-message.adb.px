--  ! WARNING: `snowpeak-message.adb` is generated by `pyexpander`.
--  ! Manually modifying this generated `.adb` file is strongly discouraged!

pragma Style_Checks ("N");

with Snowpeak.Compat; use Snowpeak.Compat;
with RFLX.RFC1157_SNMP.Message;
with RFLX.RFC1157_SNMP.Asn_Raw_SEQUENCE_OF_VarBind;
with RFLX.RFC1157_SNMP.VarBind;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
with RFLX.RFLX_Types;
with System;

$py(
from textwrap import dedent, indent
)

package body Snowpeak.Message is
   package Types renames RFLX.RFLX_Types;
   package Packet renames RFLX.RFC1157_SNMP.Message;
   package Varbind_Seq renames RFLX.RFC1157_SNMP.Asn_Raw_SEQUENCE_OF_VarBind;
   package Varbind_Packet renames RFLX.RFC1157_SNMP.Varbind;

   --  HACK: We assume here that the T and L fields in the TLV encoding are both of 1 byte.

   function I64_Length (I : I64) return Short_Length is
      J    : I64          := (if I < 0 then I + 1 else I);
      Bits : Short_Length := 1;
   begin
      loop
         J := J / 2;
         if J = 0 then
            return Bits / 8 + 1;
         end if;
         Bits := Bits + 1;
      end loop;
   end I64_Length;
   --  https://github.com/eerimoq/asn1tools/blob/44746200179038edc7d0895b03c5c0bb58285e43/asn1tools/codecs/ber.py#L253-L255

   function To_BE_Bytes (I : I64) return Types.Bytes is
      type BE_I64 is record
         Inner : I64;
      end record with
         Bit_Order            => System.High_Order_First,
         Scalar_Storage_Order => System.High_Order_First;

      for BE_I64 use record
         Inner at 0 range 0 .. 63;
      end record;

      subtype I64_Bytes is Types.Bytes (1 .. 8);
      function As_Bytes is new Ada.Unchecked_Conversion (BE_I64, I64_Bytes);

      Len : constant Short_Length := I64_Length (I);
   begin
      return As_Bytes ((Inner => I)) (Types.Index (8 - Len + 1) .. 8);
   end To_BE_Bytes;

   function Length (Self : TLV) return Short_Length is
     (Short_Length (if Self.Data = null then 0 else Self.Data.all'Length));

   function Length (Self : Varbind) return Short_Length is
     (Short_Length (Self.OID.Length) + Self.Variable.Length + 2 * 2);

   function Length (Self : PDU) return Short_Length is
      Res : Short_Length :=
        Short_Length
          (I64_Length (Self.Request_ID) + I64_Length (Self.Error_Status) +
           I64_Length (Self.Error_Index)) +
        4 * 2;
      --  + [for V of Self.Variable_Bindings.View => V.Length + 2]'Reduce("+", 0)
   begin
      --  HACK: Workaround for compiler internal error in version `23.0w-20220508`.
      for V of Self.Variable_Bindings.View loop
         Res := @ + V.Length + 2;
      end loop;
      return Res;
   end Length;

   function Length (Self : Message) return Short_Length is
     (I64_Length (Self.Version) + Short_Length (Self.Community.Length) +
      Self.Data.Length + 3 * 2);

   function Write (Item : Message) return Stream_Element_Array is
      Buffer : Types.Bytes_Ptr :=
        new Types.Bytes (1 .. Types.Index (Snowpeak.Max_UDP_Payload_Size));
      Context : Packet.Context;
      Res     :
        Stream_Element_Array
          (1 .. Stream_Element_Offset (Snowpeak.Max_UDP_Payload_Size));

      procedure Free is new Ada.Unchecked_Deallocation
        (Types.Bytes, Types.Bytes_Ptr);
   begin
      Packet.Initialize (Context, Buffer);

$py(
def set_field(
   rflx_field,
   tag_class, tag_form, tag_num, length,
   value="", variant="Untagged",
   packet="Packet", context="Context"
):
   if rflx_field:
      rflx_field += "_"

   res = f"""\
      {packet}.Set_{rflx_field}Tag_Class ({context}, RFLX.Prelude.Asn_Tag_Class ({tag_class}));
      {packet}.Set_{rflx_field}Tag_Form ({context}, RFLX.Prelude.Asn_Tag_Form ({tag_form}));
      {packet}.Set_{rflx_field}Tag_Num ({context}, RFLX.Prelude.Asn_Tag_Num ({tag_num}));
      {packet}.Set_{rflx_field}{variant}_Length ({context}, RFLX.Prelude.Asn_Length ({length}));\
"""

   if value:
      res += f"""
      {packet}.Set_{rflx_field}{variant}_Value ({context}, {value});\
"""

   return res

def sequence(field): return ("0", "1", "16", f"{field}.Length")

def integer(field):
   return ("0", "0", "2", f"I64_Length ({field})", f"To_BE_Bytes ({field})")

def octet_string(field):
   return ("0", "0", "4", f"{field}.Length", f"Types.Bytes ({field}.View)")

def object_identifier(field):
   return ("0", "0", "6", f"{field}.Length", f"Types.Bytes ({field}.View)")

VARBIND_CONTEXT = {"packet": "Varbind_Packet", "context": "Varbind_Context"}
)

$(set_field("", *sequence("Item")))

      --  version: int
$(set_field("Untagged_Value_version", *integer("Item.Version")))

      --  community: Bytes
$(set_field("Untagged_Value_community", *octet_string("Item.Community")))

      --  TODO: Support get-next-request?
$(set_field(
   "Untagged_Value_data",
   "2", "1", "2", "Item.Data.Length", variant="get_response",
))

      --  data_get_response@request_id: int
$(set_field(
   "Untagged_Value_data_get_response_Value_request_id",
   *integer("Item.Data.Request_ID"),
))

      --  data_get_response@error_status: int
$(set_field(
   "Untagged_Value_data_get_response_Value_error_status",
   *integer("Item.Data.Error_Status"),
))

      --  data_get_response@error_index: int
$(set_field(
   "Untagged_Value_data_get_response_Value_error_index",
   *integer("Item.Data.Error_Index"),
))

      --  data_get_response@variable_bindings: Seq<Varbind>
$(set_field(
   "Untagged_Value_data_get_response_Value_variable_bindings",
   *sequence("Item.Data.Variable_Bindings"),
))

      declare
         Varbind_Seq_Context : Varbind_Seq.Context;
         Varbind_Context : Varbind_Packet.Context;
      begin
         Packet.Switch_To_Untagged_Value_data_get_response_Value_variable_bindings_Untagged_Value
            (Context, Varbind_Seq_Context);
         for Element of Item.Data.Variable_Bindings.View loop
            Varbind_Seq.Switch (Varbind_Seq_Context, Varbind_Context);

$(indent(
   set_field("", *sequence("Element"), **VARBIND_CONTEXT),
   "   "*2,
))

$(indent(
   set_field("Untagged_Value_name", *object_identifier("Element.OID"), **VARBIND_CONTEXT),
   "   "*2,
))

         --  Write `Element.Variable` to `Untagged_Value_value`.
$py(
VAR_FIELD = "Untagged_Value_value"

def var_variant(class_, form, num, variant, set_data=True):
   kwargs = {
      "length": "Element.Variable.Length",
      "variant": variant,
      **VARBIND_CONTEXT,
   }

   if set_data: kwargs["value"] ="Element.Variable.Data.all"

   return (
      f"if Element.Variable.Tag_Class = {class_}\n"
      f"   and then Element.Variable.Tag_Form = {form}\n"
      f"   and then Element.Variable.Tag_Num = {num}\n"
      "then\n" \
      + indent(
         dedent(set_field(
            VAR_FIELD,
            class_, form, num,
            **kwargs,
         )),
         "   ",
      ) \
      + "\nend if;"
   )

VAR_APPLICATION = "application_wide_"
VAR_SIMPLE = "simple_"

VAR_VARIANTS = [
   ("0", "0", "2", VAR_SIMPLE + "number"),
   ("0", "0", "4", VAR_SIMPLE + "string"),
   ("0", "0", "5", VAR_SIMPLE + "empty", False),
   ("0", "0", "6", VAR_SIMPLE + "object"),
   ("1", "0", "0", VAR_APPLICATION + "address_internet"),
   ("1", "0", "1", VAR_APPLICATION + "counter"),
   ("1", "0", "2", VAR_APPLICATION + "gauge"),
   ("1", "0", "3", VAR_APPLICATION + "ticks"),
   ("1", "0", "4", VAR_APPLICATION + "arbitrary"),
]
)

$for (v in VAR_VARIANTS)
$(indent(var_variant(*v), "   "*4))
$("")
$endfor
            Varbind_Seq.Update (Varbind_Seq_Context, Varbind_Context);
         end loop;
      end;

      Packet.Take_Buffer (Context, Buffer);
      Res := To_Ada_Stream (Buffer.all);
      Free (Buffer);
      return Res;
   end Write;
   --  https://stackoverflow.com/a/22770989

   function From_BE_Bytes (Raw : Types.Bytes) return I64 is
      First : constant Types.Byte := Raw (Raw'First);
      Res   : I64                 := I64 (First mod 2**7);
      Pos   : constant Boolean    := First / (2**7) = 0;
   begin
      for I in Raw'First + 1 .. Raw'Last loop
         Res := @ * (2**8) + I64 (Raw (I));
      end loop;
      return (if Pos then Res else Res - 2**(8 * Raw'Length - 1));
   end From_BE_Bytes;

   function Read
     (Buffer : Stream_Element_Array; Last : Stream_Element_Offset)
      return Message
   is
      Context : Packet.Context;
      Res : Message;
   begin
      declare
         Bytes_Buffer : Types.Bytes_Ptr := new Types.Bytes'(To_RFLX_Bytes
            (Buffer (1 .. Last)));
         Size : constant Integer :=  Integer (Bytes_Buffer.all (2));
      begin
         pragma Assert (Size < 128);
         --  ... so that it's actually a 7-bit length.
         Packet.Initialize (Context, Bytes_Buffer,
            Written_Last => 8 * 2 + Bit_Length (8 * Size));
         Packet.Verify_Message (Context);
         pragma Assert (Packet.Structural_Valid_Message (Context));
         --  TODO: Add some error handling.

$py(
def get_field(rflx_field, assignment, packet="Packet", context="Context"):
   untagged_value = f"{rflx_field}_Untagged_Value"
   return f"""\
         declare
            Size : constant Types.Bit_Length := {packet}.Field_Size
               ({context}, {packet}.F_{untagged_value});
            Buffer : Types.Bytes (1 .. Types.To_Index (Size));
         begin
            {packet}.Get_{untagged_value} ({context}, Buffer);
            {assignment}
         end;\
"""
)

         --  version: int
$(get_field(
   "Untagged_Value_version",
   "Res.Version := From_BE_Bytes (Buffer);",
))

         --  community: Bytes
$(get_field(
   "Untagged_Value_community",
   "for C of Buffer loop Res.Community.Push (C); end loop;",
))

         --  TODO: Support get-next-request?

         --  data_get_request@request_id: int
$(get_field(
   "Untagged_Value_data_get_request_Value_request_id",
   "Res.Data.Request_ID := From_BE_Bytes (Buffer);",
))

         --  data_get_request@error_status: int
$(get_field(
   "Untagged_Value_data_get_request_Value_error_status",
   "Res.Data.Error_Status := From_BE_Bytes (Buffer);",
))

         --  data_get_request@error_index: int
$(get_field(
   "Untagged_Value_data_get_request_Value_error_index",
   "Res.Data.Error_Index := From_BE_Bytes (Buffer);",
))

         --  data_get_request@variable_bindings: Seq<Varbind>
         declare
            Varbind_Seq_Context : Varbind_Seq.Context;
            Varbind_Context : Varbind_Packet.Context;
         begin
            Packet.Switch_To_Untagged_Value_data_get_request_Value_variable_bindings_Untagged_Value
               (Context, Varbind_Seq_Context);
            while Varbind_Seq.Has_Element (Varbind_Seq_Context) loop
               declare
                  Element : Varbind;
               begin
                  Varbind_Seq.Switch (Varbind_Seq_Context, Varbind_Context);
                  Varbind_Packet.Verify_Message (Varbind_Context);

$(indent(get_field(
   "Untagged_Value_name",
   "for C of Buffer loop Element.OID.Push (C); end loop;",
   **VARBIND_CONTEXT,
), "   "*3))

                  Res.Data.Variable_Bindings.Push (Element);
                  Varbind_Seq.Update (Varbind_Seq_Context, Varbind_Context);
               end;
            end loop;
         end;
         return Res;
      end;
   end Read;
end Snowpeak.Message;
